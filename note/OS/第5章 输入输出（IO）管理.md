[toc]

# 第5章 输入/输出（I/O）管理

## 5.1 I/O管理概述

### 5.1.1 I/O设备

#### 1.基本概念

定义：将数据输入/输出计算机的外部设备。

按使用特性分类：

+ 人机交互类外部设备
+ 存储设备
+ 网络通信设备

按传输速率分类：

+ 低速设备
+ 中速设备
+ 高速设备

**按信息交换的单位分类：**

+ 块设备；传输速率较高，可寻址，即对它可**随机**地读/写任一块
+ 字符设备；传输速率较慢，不可寻址，在输入/输出时常采用**中断驱动**方式

#### 2. I/O控制器

​		CPU无法直接控制I/O设备的机械部件，因此I/O设备还要有一个电子部件作为CPU和I/O设备机械部件之间的 “中介”，用于实现CPU对设备的控制。 这个电子部件就是**I/O控制器**，又称**设备控制器**。CPU可控制I/O控制器，又由I/O控制器来控制设备的机械部件。

![image-20210721201549513](https://raw.githubusercontent.com/F-bee/professional_course_image/master/OS/image-20210721201549513.png)



![image-20210721201948117](https://raw.githubusercontent.com/F-bee/professional_course_image/master/OS/image-20210721201948117.png)

**小细节：**

1. 一个I/O控制器可能会对应多个设备；
2. 数据寄存器、控制寄存器、状态寄存器可能有多个（如：每个控制/状态寄存器对应一个具体的设备），且这些寄存器都要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为**内存映像I/O**；另一些计算机则采用I/O专用地址，即**寄存器独立编址**。

![image-20210721202816854](https://raw.githubusercontent.com/F-bee/professional_course_image/master/OS/image-20210721202816854.png)

![image-20210721203306638](https://raw.githubusercontent.com/F-bee/professional_course_image/master/OS/image-20210721203306638.png)

### 5.1.2 I/O控制方式

#### 1. 程序直接控制方式

![image-20210721204028829](https://raw.githubusercontent.com/F-bee/professional_course_image/master/OS/image-20210721204028829.png)

![image-20210721204754595](https://raw.githubusercontent.com/F-bee/professional_course_image/master/OS/image-20210721204754595.png)

#### 2. 中断驱动方式

​		CPU发出读/写命令后，可**将等待I/O的进程阻塞**，先切换到别的进程执行。当I/O 完成后，控制器会向CPU发出一个中断信号，CPU**检测到中断信号后**，会保存当前进程的运行环境信息，转去执行中断处理程序 处理该中断。处理中断的过程中，CPU从I/O控制器读一个字的数据传送到CPU寄存器，再写入主存。接着，**CPU恢复等待I/O的进程（或其他进程）的运行环境，然后继续执行**。

**【注】**1. CPU会在每个指令周期的末尾检查中断；<br>			2. 中断处理过程中需要保存、恢复进程的运行环境， 这个过程是需要一定时间开销的。可见，如果中断发生的频率太高，也会降低系统性能。

主要缺点和主要优点：

​		优点：与 “程序直接控制方式” 相比，在 “中断驱动方式” 中，I/O控制器会通过中断信号主动报告I/O已完成，CPU不再需要不停地轮询。**CPU和I/O设备可并行工作**，CPU利用率得到明显提升。

​		**缺点**：每个字在I/O设备与内存之间的传输，都需要经过CPU。而**频繁的中断处理会消耗较多的CPU时间**

#### 3. DMA方式

​		与 “中断驱动方式” 相比，**DMA方式**（ Direct Memory Access，**直接存储器存取**。主要用于块设备的 I/O控制）有这样几个改进： <br>① **数据的传送单位是 “块”**。不再是一个字、一个字的传送； <br>② 数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要CPU作为 “快递小哥”。 <br>③ 仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。

![image-20210721211655309](https://raw.githubusercontent.com/F-bee/professional_course_image/master/OS/image-20210721211655309.png)

#### 4. 通道控制方式

![image-20210722090419288](https://raw.githubusercontent.com/F-bee/professional_course_image/master/OS/image-20210722090419288.png)

![image-20210722090156078](https://raw.githubusercontent.com/F-bee/professional_course_image/master/OS/image-20210722090156078.png)

### 5.1.3 I/O子系统的层次结构

![image-20210722095254932](https://raw.githubusercontent.com/F-bee/professional_course_image/master/OS/image-20210722095254932.png)

**各层次的功能**

![image-20210722100241337](https://raw.githubusercontent.com/F-bee/professional_course_image/master/OS/image-20210722100241337.png)

​		理解并记忆I/O软件**各个层次之间的顺序**，要能推断某个处理应该是在哪个层次完成的。<br>		**设备驱动程序**和**中断处理程序**是直接和硬件打交道的，所以直接涉及到硬件细节相关操作的话，一定是这两层完成的；此外，没有涉及硬件的、对各种设备都需要进行的管理工作都是在**设备独立性软件**层完成的。<br>		设备独立性软件层的功能⑥，建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序；即**逻辑设备表（LUT，Logical Unit Table）**的作用。

**过程理解：**

用户通过调用用户层软件提供的库函数发出的I/O请求<br>	step1：用户层软件通过“系统调用”请求设备独立性软件层的服务<br>	step2：设备独立性软件层根据LUT调用设备对应的驱动程序<br>	step3：驱动程序向I/O控制器发出具体命令<br>	step4：等待I/O完成的进程应该被阻塞，因此需要进程切换，而进 程切换必然需要中断处理

## 5.2 I/O核心子系统

### 5.2.1 I/O子系统概述

​		I/O核心子系统要实现的功能其实就是I/O子系统层次的中间三层，即**设备独立性软件、设备驱动程序、中断处理程序**要实现的功能。<br>		需要重点理解和掌握的功能 是：I/O调度、设备保护、假脱机技术 （SPOOLing技术）、设备分配与回收、缓 冲区管理（即缓冲与高速缓存）。其中**假脱机技术（SPOOLing 技术）**需要请求 “磁盘设备” 的设备独立性软的服务，因此一般来说假脱机技术是在实现的；但408大纲将假脱机技术归为**I/O核心子系统**的功能。

+ I/O调度：用某种算法确定一个好的顺序来处理各个I/O请求
+ 设备保护：在UNIX系统中，**设备被看做是一种特殊的文件**，每个设备也会有对应的FCB。操作系统需要实现文件保护功能，不同的用户对各个文件有不同的访问权限

### 5.2.2 缓冲区

​		缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。<br>		使用硬件作为缓冲区的**成本较高，容量也较小**，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）。<br>		一般情况下，更多的是用**内存作为缓冲区**，“设备独立性软件”的缓冲区管理就是要组织管理 好这些缓冲区。

![image-20210722155024555](https://raw.githubusercontent.com/F-bee/professional_course_image/master/OS/image-20210722155024555.png)

**【注】缓冲区的特点：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。**

根据系统设置缓冲器的个数，缓冲技术可分为：单缓冲、双缓冲、循环缓冲和缓冲池：

![image-20210722155444338](https://raw.githubusercontent.com/F-bee/professional_course_image/master/OS/image-20210722155444338.png)

### 5.2.3 设备分配与回收

​		设备分配指根据**用户的I/O请求**分配所需的设备。分配的总原则是**充分发挥设备的使用效率，尽可能地让设备忙碌，又要避免由于不合理的分配方法造成进程死锁**。

#### 1. 设备分配时应考虑的因素

![image-20210722113356612](https://raw.githubusercontent.com/F-bee/professional_course_image/master/OS/image-20210722113356612.png)

**（1）设备的固有属性可分为三种：独占设备、共享设备、虚拟设备**

+ 独占设备——一个时段只能分配给一个进程（如打印机）
+ 共享设备——可同时分配给多个进程使用（如磁盘），各进程往往是宏观上同时共享使用设备，而微观上交替使用
+ 虚拟设备——采用 SPOOLing 技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用 SPOOLing 技术实现的共享打印机）

**（2）设备的分配算法**

​		先来先服务；优先级高者优先；短任务优先；……

**（3）从进程运行的安全性上考虑，设备分配有两种方式**

+ 安全分配方式：为进程分配一个设备后就将进程阻塞，本次I/O完成后才将进程唤醒。

    一个时段内每个进程只能使用一个设备

  + 优点：破坏了 “请求和保持” 条件，不会死锁
  + 缺点：对于一个进程来说，CPU和I/O设备只能串行工作

+ 不安全分配方式：进程发出I/O请求后，系统为其分配I/O设备，进程可继续执行，之后还可以发出新的I/O请求。只有某个I/O请求得不到满足时才将进程阻塞。

    一个进程可以同时使用多个设备

  + 优点：进程的计算任务和I/O任务可以并行处理，使进程迅速推进
  + 缺点：有可能发生死锁（死锁避免、死锁的检测和解除）

+ 设备分配方式

  + 静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源（破坏了“请求和保持”条件，不会发生死锁）
  + 动态分配：进程运行过程中动态申请设备资源

#### 2. 设备分配管理中的数据结构

​		一个通道控制多个控制器，一个控制器控制多个设备。

+ 设备控制表（DCT）：每个设备对应一张DCT，关键字段：类型/标识符/状态/指向COCT的指针/等待队列指针
+ 控制器控制表（COCT）：每个控制器对应一张COCT，关键字段：状态/指向CHCT的指针/等待队列指针
+ 通道控制表（CHCT）：每个通道对应一张CHCT，关键字段：状态/等待队列指针
+ 系统设备表（SDT）：记录整个系统中所有设备的情况，每个设备对应一个标目，关键字段：设备类型/标识符/DCT/驱动程序入口

#### 3. 设备分配的步骤

① 根据进程请求的物理设备名查找SDT（注：物理设备名是进程请求分配设备时提供的参数）<br>② 根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程<br>③ 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程 <br>④ 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程

#### 4. 设备分配步骤的改进

**原步骤存在的缺点：**

① 用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程 <br>② 若换了一个物理设备，则程序无法运行<br>③ 若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待

**改进方法：**

​		建立**逻辑设备名与物理设备名的映射机制**，用户编程时只需提供逻辑设备名，操作系统负责实现从逻辑设备名到物理设备名的映射（通过**LUT**）。

① 根据进程请求的**逻辑设备名**查找SDT（**注：用户编程时提供的逻辑设备名其实就是 “设备类型” **）<br>② 查找SDT，找到用户进程**指定类型的、并且空闲**的设备，将其分配给该进程。操作系统**在逻辑设备表（LUT）中新增一个表项**<br>③ 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程<br>④ 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程

**逻辑设备表的设置问题：**

+ 整个系统只有一张LUT：各用户所用的逻辑设备名不允许重复，适用于单用户操作系统
+ 每个用户一张LUT：不同用户的逻辑设备名可重复，适用于多用户操作系统

### 5.2.4 SPOOLing技术（假脱机技术）

​		脱机：指脱离主机的控制进行的输入/输出操作，缓解设备与CPU的速度矛盾，实现预输入、假输出；SPOOLing 的意思是**外部设备同时联机操作**，又称假脱机输入/输出操作，是操作系统中采用的一项**将独占设备改造成共享设备**的技术。是用软件的方式模拟脱机技术。

​		SPOOLing 系统的组成：

![image-20210722111003965](https://raw.githubusercontent.com/F-bee/professional_course_image/master/OS/image-20210722111003965.png)

+ 输入井和输出井（磁盘中）

  在磁盘上开辟出两个存储区域—— “输入井” 和 “输出井”；

  + “输入井” 模拟脱机输入时的**磁带**，用于收容I/O设备输入的数据
  + 输出井”模拟脱机输出时的**磁带**，用于收容用户进程输出的数据

+ 输入进程和输出进程

  要实现 SPOOLing 技术，必须要有多道程序技术的支持。系统会建立 “输入进程” 和 “输出进程”；

  + 输入进程 ”模拟脱机“ 输入时的**外围控制机**
  + 输出进程”模拟脱机” 输出时的**外围控制机**

+ 输入缓冲区和输出缓冲区

  输入缓冲区和输出缓冲区是在内存中的缓冲区，输入、输出时的 “中转站”；

  + 在输入进程的控制下，“输入缓冲区” 用于暂存从输入设备输入的数据，之后再转存到输入井中
  + 在输出进程的控制下，“输出缓冲区” 用于暂存从输出井送来的数据，之后再传送到输出设备上